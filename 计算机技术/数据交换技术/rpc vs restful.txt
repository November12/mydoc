不管是RPC, 还是Rest, 我们在这里都是讨论"如何解决访问服务的问题"

-------------------------------------------------------------------------------------------------

RPC(Remote Procedure Call) - 远程过程调用协议(面向方法)

RPC采用客户机/服务器模式。
客户在本地调用RPC，就像是在本地执行一个函数一样。
像调用本地服务(方法)一样调用服务器的服务(方法).
通常的实现有 XML-RPC , JSON-RPC , 通信方式基本相同, 所不同的只是传输数据的格式.

先看一下普通的请求-应答方式:
假如服务器端有一个非常NB的算法，告诉他今天的彩票中奖号码，以及N天，它就能返回N天后的彩票中奖号码。
  问题一: 为了从服务端请求这个服务，需要先定义这个服务的协议
    struct input {
      char number[6];
      int N;
    }
    struct output {
      char number[6];
    }
  以及内部的数据如何序列化和反序列化。
  如果是成千上万的应用呢，是否需要成千上万的类似协议?
  
  问题二: 有了协议不行，还需要和服务器建立连接(也可以是Http连接等等)
    int fd = socket();
    connetct(fd..);
    send/recv(fd..);
  如果有1000个人需要调用这个服务，这1000个人都要自己编写类似的调用代码?
  
  问题三: 连接某个服务器肯定不行的，如果这个服务器宕掉了怎么办，所以客户端需要写这样的代码
    connect fd1, fd2, fd3;
    fd = SelectFd();    // 路由算法，可实现负载均衡和容错
    send/recv(fd..);
  同样的，这1000个调用者都需要这么写，都需要应该这么写。
  
  显然，这对于应用开发者来说，要做的事情太多了，重复做的事情太多了。
  
  当然这样做对服务端也有好处, 所以，大型国企和垄断企业往往采用这种方式提供服务。
    1. 无需提供客户端lib，省去了很多发布lib, 维护版本的工作。
    2. 省去了开发客户端lib，以及无需为客户端lib的任何bug承担责任。
 
通过RPC调用，将上面这些细节全都隐藏起来，极大的方便了调用者的开发量。
  char* TellNumber(char *number, int N);
  调用者无需考虑业务之外的问题，调用一个函数，仅此而已。(序列化，连接，路由..)
  
当然, RPC也不完美:(因为这个问题，出现了REST)
  1. 由于lib, 使得接口和语言有关。如果想用接口，必须采用能加载lib的语言。
  2. 每一次添加接口，不得不升级lib。(问题还是出在lib)
  
 
RPC OVER HTTP
  一种中间件技术, 通过代理和RPC服务器交互
  客户端 -> RPC代理 -> RPC服务器
  
-------------------------------------------------------------------------------------------------

REST 不是一种协议,它是一种架构, 一种 Web Service 能够如果满足 REST 的几个条件, 通常就称这个系统是 Restful 的
这几个条件是:
  1.C/S结构 (这是Internet服务的一个基本特征)
  2.无状态 (很熟悉吧,呵呵)
  3.可以cache (想起了浏览器?)
  4.分层系统 (想起了无数的架构?)
  5.统一的接口 (如果这是可能的,程序员有福了, :D)
  6.code on demand(可选, 其实是一种扩展性的要求)
  
3个概念, 以HTTP为例: 
  名词即为URI(统一资源标识)
  动词包括POST, GET, PUT, DELETE等(还有其它不常用的2个,所以 整个动词集合是有限的)
  资源的形态(如text, html, image, pdf等)
  
RPC与REST的区别
  RPC是以动词为中心的, REST是以名词(资源)为中心的
  
RPC相对RPC的优势:
  1. 扩展性
  2. 松耦合(意味着,不用强制要求客户端去更新相应的代码)
  3. 客户端实现语言无关
  4. 性能
  5. 安全性(例如HTTPS)



  





-------------------------------------------------------------------------------------------------

2.SOA - service-oriented architecture, 
面向服务的体系结构, 是面向对象的模型的替代模型，

具有中立的接口定义
接口是采用中立方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。




面向服务的体系结构中的角色:
1、服务请求者：
  通过对注册中心中的服务的查询，根据接口契约来请求(执行)服务
2、服务提供者：
  它将自己的服务和接口契约发布到服务注册中心，以便服务请求者可以发现和访问该服务。
  通过网络寻址, 接受和执行来自请求者的请求。
3、服务注册中心：
  

面向服务的体系结构中的操作包括:
发布：为了使服务可访问．需要发布服务描述以使服务请求者可以发现和调用它。
查询：服务请求者定位服务．方法是查询服务注册中心来找到满足其标准的服务。
绑定和调用：在检索完服务描述之后，服务请求者继续根据服务描述中的信息来调用服务。


面向服务的体系结构中的构件包括：
服务：可以通过已发布接口使用服务，并且允许服务使用者调用服务。
服务描述：服务描述指定服务使用者与服务提供者交互的方式。它指定来自服务的请求和响应的格式。服务描述可以指定一组前提条件、后置条件和/或服务质量（Q0S）级别。


SOA具有以下五个特征:
1、可重用        一个服务创建后能用于多个应用和业务流程。
2、松耦合        与技术细节无关，例如程序语言、底层平台等等。
3、明确定义的接口   WSDL
4、无状态的服务设计    服务应该是独立的、自包含的请求，在实现时它不需要获取从一个请求到另一个请求的信息或状态。服务不应该依赖于其他服务的上下文和状态。当产生依赖时，它们可以定义成通用业务流程、函数和 数据模型。
5、基于开放标准     无需自己定义


SOA服务具有平台独立的自我描述XML文档。Web服务描述语言（WSDL， Web Services Description Language）是用于描述服务的标准语言。 
SOA 服务用消息进行通信，该消息通常使用XML Schema来定义


[SOA]REST与SOA两种架构的异同比较(2012-04-04 22:07:31)转载标签： soarestit 分类： 应用架构  
REST的特性 
它基于HTTP协议，是一种明确构建在客户端/服务端体系结构上的一种风格。特征如下：
1、网络上的资源都被抽象为资源，这些资源都具有唯一的统一资源标识符(URI：Uniform Resource Identiter)，这些资源都是自我们描述的。这些资源使用HTTP内容标头类型指定。如：XML、JSON、HTML、PNG等。
2、服务的使用者通过HTTP协议的标准动作(Get、Put、Post、Delete)通过统一的接口对资源进行操作。
3、对资源进行的操作不会改变它的URI。
4、客户端、服务端之间的交互是没有状态的。由于这种无状态行，服务端不需要为每个客户端维护Context


SOA的特征
1、通过网络终结点对外提供服务。
2、粗粒度的服务接口。


REST与SOA的共同点
REST与SOA两者，虽有不同点，但是他们都作为服务的不同架构风格，具有服务的一般属性。具体如下：
1、统一的服务契约接口与服务接口
2、松散的耦合。
3、只要有权限都可以进行访问


REST与SOA的不同点
1、REST风格下的，只有一种协议，那就是HTTP。而SOA下的WCF就和多种协议了。如：TCP、HTTP、MSMQ等多种协议
2、使用方式上的不同。REST只要客户端能够模拟HTTP请求，通过标准的HTTP动作，都可以进行访问。它使用的是HTTPChannel管道，而SOA使用的管道有HTTPChannel、TcpChannel、RPC等多种。
3、REST寄宿时，虽然可以选择多种寄宿方式，但必须有应用服务器的支持。



























附一: RESTful API 设计最佳实践
  API的就是程序员的UI, 必须仔细考虑它的用户体验!
  REST的核心原则是将你的API拆分为逻辑上的资源。这些资源通过http被操作（GET ,POST,PUT,DELETE）。
  
  定义好逻辑资源，以及资源上允许的操作
    GET /tickets # 获取ticket列表
    GET /tickets/12 # 查看某个具体的ticket
    POST /tickets # 新建一个ticket
    PUT /tickets/12 # 更新ticket 12.
    DELETE /tickets/12 #删除ticekt 12
    
  REST可以充分利用http实现对资源的CURD功能
  
  永远使用SSL

  版本化
    版本信息是放到<header>里面，还是放到url里面，是一个永远争论的话题
  

  命名规则:
    url越短越好，尽量用参数实现。而对于经常会使用到的查询，又应该连同参数一起，形成别名。
  
  json优于xml
    尽量选择json，短小精干。但在很多场合，xml可能是唯一的选择。

  蛇形命名还是驼峰命名
    尽量遵循各语言命名方式
    
    
    
    



