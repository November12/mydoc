消息中间件: Message Oriented Middleware，MOM
MOM要解决的问题:
  生产者直接把数据发送给消费者，会产生以下问题:
    1. 同步通信: 生产者必须确认收到，才能继续执行
    2. 生命周期耦合: 任意一方断开，将导致通信停止等待
    3. 点对点: 只能发送给一个消费者，多个消费者的时候不容易处理。
    
  通过MOM，即可解决这些问题。(不用解释了吧)
  

  
两种消息模型:
  Java Message Service(JMS)是SUN提出的旨在统一各种MOM系统接口的规范, JMS只是接口，并没有给予实现
  提供可靠消息传输、事务和消息过滤等机制
  
  1. PTP(点对点): Point to Point
    只能有一个消费者
    消息首先被传送至队列目标, 然后根据队列传送策略
  

  2. pub/sub(发布/订阅): Publish/Subscribe
    目标是一个主题(Topic)。消息首先被传送至主题目标，然后传送至所有已订阅此主题的活动消费者。
    主题目标也支持持久订阅的概念。确保数据一定能被收到。
    
  
    
    
1.2 JMS的可靠性机制
 1. 确认  
  JMS消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费。
  通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。
  
  在事务性会话中，当一个事务被提交的时候，确认自动发生。
  在非事务性会话中，消息何时被确认取决于创建会话时的应答模式(acknowledgement mode)

  该参数有以下三个可选值：
    Session.AUTO_ACKNOWLEDGE
      当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。
    Session.CLIENT_ACKNOWLEDGE
      客户通过消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。
      例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。
    Session.DUPS_ACKNOWLEDGE
      该选择只是会话迟钝第确认消息的提交。
  
  2. 持久性
    JMS 支持以下两种消息提交模式：
      PERSISTENT
        该消息一定要被送到目的地，否则会导致应用错误。
      NON_PERSISTENT
        表示偶然丢失该消息是被允许的。
  
  3. 优先级
    可以使用消息优先级来指示，优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4。
    JMS provider并不一定保证按照优先级的顺序提交消息。
 
  4. 消息过期
    设置消息在一定时间后过期，默认是永不过期。
  
  5. 临时目的地
    可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。
    只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。它们的存在时间只限于创建它们的连接所保持的时间。

  6. 持久订阅
    首先消息生产者必须使用PERSISTENT提交消息。
    客户可以通过会话上的createDurableSubscriber方法来创建一个持久订阅
    同一个客户指的是: 相同的连接工厂, 相同的连接的客户ID, 相同的主题, 相同的订阅名
    持久订阅在某个时刻只能有一个激活的订阅者。
    持久订阅在创建之后会一直保留，直到应用程序调用会话上的unsubscribe方法。
  
  7. 本地事务
    在一个JMS客户端，可以使用本地事务来组合消息的发送和接收。
    JMS Session接口提供了commit和rollback方法。
    事务提交意味着生产的所有消息被发送，消费的所有消息被确认；事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非它们已经过期。
     
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    