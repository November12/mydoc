1. 下载软件包  # wget http://www.keepalived.org/software/keepalived-1.1.15.tar.gz2. 安装  # tar zxvf keepalived-1.1.15.tar.gz  # cd keepalived-1.1.15  # ./configure  && make && make install  # find / -name keepalived           # 查看keepalived位置  # cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/  # cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/  # mkdir /etc/keepalived  # cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/  # cp /usr/local/sbin/keepalived /usr/sbin/  # service keepalived start|stop     # 做成系统启动服务方便管理.  启动时直接service keepalived start 无需再运行lvs的脚本lvs_dr.sh3. 配置keepalived  # vim /etc/keepalived/keepalived.conf  在其中可配置Master, VIP, 和RS. 关键部分如下：　　vrrp_instance VI_1 {    state MASTER                  # 备份服务器上将MASTER改为BACKUP       interface eth0    virtual_router_id 51    priority 100                  # 备份服务上将100改为99    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    virtual_ipaddress {        10.15.107.225         #(如果有多个VIP，继续换行填写.)    }　　}　　　　virtual_server 10.15.107.225 {    delay_loop 6                    # 每隔6秒查询realserver状态    lb_algo wlc                     # lvs算法    lb_kind DR                      # Direct Route    persistence_timeout 0           # 同一IP的连接60秒内被分配到同一台realserver    protocol TCP                    # 用TCP协议检查realserver状态    real_server 10.15.107.76 4042 {        weight 1                    # 权重        TCP_CHECK {        connect_timeout 10          # 10秒无响应超时        nb_get_retry 3        delay_before_retry 3        connect_port 4042        }    }    real_server 10.15.107.141 4042{        weight 1        TCP_CHECK {        connect_timeout 10        nb_get_retry 3        delay_before_retry 3        connect_port 4042        }     }　　}　　　4. 测试  1）两台RealServer都正常工作，两台client先后去连VIP.     DR上运行 watch ipvsadm -lcn, 两个连接分别分配给两个RS. 测试OK.  2) 76上停止mysql-proxy, 两台client先后去连VIP.     DR上运行 watch ipvsadm -lcn, 两个连接全部分配给正常工作的RS(141), 测试OK.5. 分析keepalived检测RS健康的机制   在测试的第二种情况下，在DR上抓取DR与两个RS之间的数据包，进一步分析keepalived检测RS健康的机制。    /usr/sbin/tcpdump -i eth0 host \(10.15.107.76 or 10.15.107.141\) and 10.15.107.80 and port 4042 -xns 0 -w keepalived_one_con    从其中可以清楚得看到keepalived每隔6秒向两台RS分别发送SYN包，    不健康的RS（76）向DR发送RST包，健康的RS(141)向DR发送正常的ACK包，    接到这个ACK包后，DR向RS（141）发送ACK包，与其成功完成三次握手，建立tcp连接，    紧接着DR马上向RS(141)发送RST包，关闭刚建立的tcp连接。