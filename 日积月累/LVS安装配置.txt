1. 下载LVS  wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.24.tar.gz2. 安装LVS  # uname -r  2.6.9-78.ELsmp  # ln -s /usr/src/kernels/2.6.9-78.EL-largesmp-x86_64/ /usr/src/linux  # tar zxvf ipvsadm-1.24.tar.gz  # cd ipvsadm-1.24  # make && make install  # find / -name ipvsadm          # 查看ipvsadm的位置3. LVS启动配置  1. 通过lvs_dr.sh脚本启动，可配置此脚本实现不同模式，不同算法的负载均衡。     Lvs_dr.sh脚本中需要配置的服务器ip地址有网关，VIP， RIP，Realserver上响应请求的端口。     lvs_dr.sh start      # 启动lvs     lvs_dr.sh status     # 查看lvs状态     lvs_dr.sh stop       # 停止lvs     查看ipvsadm命令详细参数，ipvsadmin -h  2. 脚本中重要的命令说明：    2.1 /sbin/ipvsadm -A -t $MySQL_VIP:$PORT -s wlc #-p 30        在内核的虚拟服务器表中添加一条新的虚拟服务器记录。也就是增加一台新的虚拟服务器。        WLC：加权最小连接调度算法        -P 把同一个cip发来请求到同一台RS的持久超时时间，可用用ipvsadm -ln 查看，对WLC算法不需要，故在此注释掉。    2.2 /sbin/ipvsadm -a -t $MySQL_VIP:$PORT -r $MySQL_RIP2:$PORT -g -w 1        在内核虚拟服务器表的一条记录里添加一条新的真实服务器记录。即在一个虚拟服务器中增加一台新的真实服务器。        -t --tcp-service service-address 指定虚拟服务器提供的是tcp的服务        -g --gatewaying 指定LVS 的工作模式为直接路由模式（也是LVS 默认的模式）        -w --weight 真实服务器的权值    2.3 /sbin/ipvsadm --set 30 5 60        设置一个链接创建后空闲时的超时时间，这个超时时间分为3种。        1）tcp的空闲超时时间。        2）lvs收到客户端tcp fin的超时时间        3）udp的超时时间        可用ipvsadm -lnc 查看空闲等待时间。        查看timeout设置: ipvsadm -l --timeout    2.4  #/sbin/route add -host $MySQL_VIP dev eth0:0        向路由表里增加VIP地址，这个在DR模式中没有必要，所以注释掉。        在排错时，无需使用route命令去查看路由表情况，可将精力集中于关键处。4. LVS的一些统计信息命令  1. ipvsadm -l --rate     CPS      (current connection rate)   每秒连接数    InPPS    (current in packet rate)    每秒的入包个数    OutPPS   (current out packet rate)   每秒的出包个数    InBPS    (current in byte rate)      每秒入流量（字节）    OutBPS   (current out byte rate)    每秒入流量（字节）      2. ipvsadm -l --stat    统计自该条转发规则生效以来的信息    Conns    (connections scheduled)  已经转发过的连接数    InPkts   (incoming packets)       入包个数    OutPkts  (outgoing packets)       出包个数    InBytes  (incoming bytes)         入流量（字节）      OutBytes (outgoing bytes)         出流量（字节） 5. RealServer配置  1. Realserver上配置比较简单，设置realserver.sh中的VIP地址即可。    realserver.sh start     # 启动RS    realserver.sh status    # 查看RS状态    realserver.sh stop      # 停止RS  2. 脚本中重要命令说明    2.1 # /sbin/route add -host $MySQL_VIP dev lo:0         同DR配置一样，无须路由表中加入VIP.           2.2 # /sbin/ifconfig lo:0 $MySQL_VIP netmask 255.255.255.255 broadcast $MySQL_VIP        设置lo:0设备ip为VIP.6. Oracle MysqlProxy配置启动  mysql proxy 可以自己编写配置文件，在其中加入各种启动参数，配置日志文件路径和信息级别  配置文件属性修改为：    chmod 660 ../etc/mysql_proxy.cnf   启动命令：    ./mysql-proxy  --defaults-file ../etc/mysql_proxy.cnf  可参考配置文件mysql_proxy.cnf，其中    1.Basedir /u02/wangwei/mysql-proxy/mysql-proxy-0.8.3-linux-rhel5-x86-64bit/mysql-proxy-0.8.3-linux-rhel5-x86-64bit/       lua脚本的绝对基本路径，     2.proxy-lua-script = ./share/doc/mysql-proxy/ro-pooling.lua      lua脚本相对路径     3.log-file = ./log/mysql-proxy.log       log-level = debug       (error|warning|info|message|debug)    其它配置详情可参考mysql官网说明：    http://dev.mysql.com/doc/refman/5.1/en/mysql-proxy-configuration.html                                附1. LVS + OracleMysqlProxy原理验证及错误诊断  在实验中，我们遇到了RS与客户端无法正常连接通信的错误，  不能确定client与DR， DR与RS， RS与client中哪里连接出现问题，没有有效的检测方法，  经过进一步深入研究，基于DR原理，通过以下检测方法既验证其原理又可找出错误原因。　　　　　  1 实验服务器配置    1. DR：10.15.107.80， MAC address: HWaddr 00:1A:4B:E1:92:00    2. RS：10.15.107.76， MAC address: HWaddr 00:24:81:FE:0A:0C       其上部署oracle mysqlproxy, 端口4042    3. VIP：10.15.107.225 MAC address: HWaddr 00:1A:4B:E1:92:00    4. Client: 10.15.107.73， MAC address: HWaddr 00:26:55:1E:39:74    5. RS上mysqlproxy连接10.15.107.84上的mysql数据库  2 客户端连接失败    分别在80上执行lvs_dr.sh start, 76上执行realserver.sh start, 启动mysqlproxy.    在73上通过DR连接数据库，mysql -h10.15.107.225 -P4042 -ureader -Ddzhst2 -preader 结果无法连接。         3 错误检测及原理验证    通过网络抓包来找到错误原因。    查找错误原因：    1. 80上执行ipvsadm -ln, 发现76已成功加入lvs虚拟服务器记录中。    2. 80上执行ipvsadm -lnc, 发现lvs成功建立与realserver的tcp连接    3. 76上执行tcpdump, 抓取客户端（73）与VIP（225）之间的包      /usr/sbin/tcpdump -i eth0 host 10.15.107.73 and 10.15.107.225 and port 4042 -xns 0 -w lvs_con_fail      Wireshark打开lvs_con_fail    从第一条SYN报文可以看出VIP(225)将报文转给了RealServer(76)    第二条报文，握手失败    从红色标记分析：realserver(76)直接发包给client(73), 包类型为RST.    连接超时,端口 或主机不可达, RST (Reset)包将被发送, 通过互相ping, 不存在76主机不可达的情况，那问题就出在端口上。    76上执行netstat -anpt | grep 4042, 发现端口绑定的ip是10.15.107.76，通过ifconfig, 此ip对应设备是eth0. 根据DR原理，lo:0设备ip为VIP（225），有可能76判断在设备lo:0上VIP端口4042未打开。    打开mysql_proxy.cnf文件，更改proxy-address为      proxy-address =0.0.0.0:4042    重启mysqlproxy, 73上重新连接，成功。      76执行netstat -anpt | grep 4042    问题得到解决。  4 检测方法归纳    1）检查client, vip, RS直接能否互相ping通。    2）在DR上使用ipvsadm -ln 检测RS是否成功加入虚拟服务器记录        用ipvsadm -lcn检查DR与RS之间的连接状态    3）在DR上抓取client与VIP直间的包分析client包是否到达DR.    4) 在RS上抓取client与VIP直间的包，分析client与RS之间包的类型和内容。