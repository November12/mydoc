第2章 使用SQL管理数据SQL是什么? SQL是mysql的语言，要想和mysql沟通，就得用sql2.1 SQL模式sql_mode系统变量: mysql服务器对自己的模式  strict_all_table, 严格模式，任何数据类型的不一致，都将拒绝  traditional, 更接近传统的模式  ...  2.2 MySQL标识符语法和命名规则不用纠结这个问题2.3 SQL语句中的大小写问题关键字和函数名：             不区分大小写数据库、数据表、视图的名字： 将作为目录名和文件名，所以是否大小写由操作系统来定。也就是说，windows不区分，unix区分存储程序的名字:              存储函数、存储过程和事件不区分，触发器区分数据列和索引:                不区分建议不要纠结这个问题，用统一的大写或小写就行。尽量用小写，因为InnoDB统一用小写2.4 字符集支持支持多种字符集，且可以为每列指定字符集character set: 指定字符集collation:     指定字符集排序方式myslq不同的版本，在字符集上可能存在不兼容的问题2.5 数据库级的命令2.5.1 数据库的选定显式: USE db_name隐式: db_name.table不同数据库之间是可以跨库join的2.5.2 数据库的创建create database db_name会创建一个db_name的子目录，以及子目录中创建db.opt，保存数据库属性2.5.3 数据库的删除drop database db_name命令很简单，使用请小心，没办法恢复的2.5.4数据库的变更alter database2.6 数据表级的命令2.6.1 存储引擎这个题目太大了，这里不做描述2.6.2 创建数据表create table2.7 数据库的元数据  1. 各种SHOW    show databases;                   -- 所有database    show create database db_name;     -- 查看test数据库创建的命令    show tables {from db_name};       -- 查看数据库所有的表    show create table tbl_name;       -- 查看表属性    show columns from tbl_name;       -- 查看表的列属性      show index from tbl_name;         -- 查看表的索引    show table status {from db_name}; -- 列出表属性        还可以在show语句中使用like, where, 精确定位      2. IFFORMATION_SCHEMA数据库    它不是一个真实的数据库，可以认为是其它数据库元数据的视图    3. mysqlshow命令    类似于SHOW2.11 使用视图  视图是MySQL 5.0中增加的三大新功能之一（另外两个是存储过程与触发器）  它是一种虚拟表，行为和数据表一样，但数据来源于真实的数据表。  视图可以更新数据，只要和基础表的行列是一一对应的关系就行  MySQL在处理视图时有两种算法，分别称为MERGE和TEMPTABLE  MERGE: 有点类似于C语言中的宏展开，因此只能搞定非常简单的映射关系  TEMPTABLE: 顾名思义，就是先用临时表保存起来。当然这样性能会受到极大影响。\             TEMPTABLE模式优化得并不好，比如有where age = 20, mysql还是会把所有的条件都选出来，再进行where           2.12 多表的删除和更新  DELETE FROM t WHERE id > 100                              -- 删除单张表  DELETE t1 FROM t1 INNER JOIN t2 ON t1.id = t2.id          -- 关联其它表  DELETE t1, t2 FROM t1 INNER JOIN t2 ON t1.id = t2.id      -- 删除多张表  还有一种同等的写法, 看起来更舒服  DELETE FROM t1 USING t1 INNER JOIN t2 ON t1.id = t2.id  对于INNODB，还可以使用外键达到同样的效果，且性能更好  2.13 事务处理  ACID原则 　Atomic(原子性): 一个事务要么全部执行,要么不执行.   Consistent(一致性): 例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.   Isolated(独立性): 两个以上的事务不会出现交错执行的状态. 因为这样可能会导致数据不一致.    Durable(持久性): 如果事务成功, 则数据永久性的记录在数据库中。     整个事务，在此期间，其它连接看不到任何更改动作    START TRANSACTION、COMMIT、ROLLBACK      设置save point, 进行部分回滚    START TRANSACTION、SAVEPOINT a、 ROLLBACK TO SAVEPOINT a      事务的隔离性    其它用户在何时才应该看到事务的修改?      几种隔离级别:        dirty read: 脏读。事务没提交，其它用户就可以看到，这些数据有可能会被回滚。        nonrepeatable read: 不可重复读取。两次同样的select, 如果之间其它用户提交，则结果会不一致        phantom row: 突然看到以前没见过的行。        后两种都可认为是幻读现象。           InnoDB提供了4种隔离级别:        READ UNCOMMITTED: 允许脏读        READ COMMITTED: 避免了脏读，但允许nonrepeatable read        REPEATABLE READ: 避免了nonrepeatable read, 也避免了幻读        SERIALZABLE: 我看过了，别人就不能看了        事务问题的非事务解决方案    一些技巧，不能解决所有的事务问题，但可以解决部分问题。      明确的锁定数据表: LOCK TABLES, UNLOCK TABLES        锁只能保证其它用户不会进入，但不能保证事务，不能回滚的。      使用一条语句(原子操作): 如update table set count = count - 3 where user = 'xx'        这样是最好的方法，但只能解决简单的问题。        2.14 外键和引用完整性  外键可以帮助我们维护数据的一致性，否则这些工作就要交给程序去处理。  外键是在子表设置的，父表子表都需要有该列的索引，之间的关系有4种:    cascaded: 级联    No Action:     Restrict:     Set null:   可以单独为update和delete设置关系  2.15 FULLTEXT索引  mysql作全文索引并不合适，况且不支持InnoDB。就忽略它吧。  第3章   第4章 存储程序  存储程序包括: 存储函数、存储过程、触发器、事件  存储例程特指存储函数和存储过程  优点和能力    可以写出更复杂的sql, 包括循环、条件    sql保存在服务器端，减少了网络传输的开销    实现标准化的操作，只需要简单的通过名字来调用    提供了错误处理机制    提高了数据库的安全性，可以设置每个存储程序的权限  存储函数和存储过程    存储函数      CREATE FUNCTION      将返回一个计算结果, 结果可以用在表达式里面, 向hex()      存储函数不允许对调用本函数的语句正在读写的表进行修改    存储过程      CREATE PROCEDURE      调用时必须使用call      存储过程没有返回值，没有return, 但可以通过out参数来返回    权限      可以设置创建、执行、修改权限    参数类型      三种参数类型: IN, OUT, INOUT      对于存储函数，类型都是IN,   触发器    CREATE TRIGGER    触发器是与特定存储表相关联的存储过程。    触发方式共有6种，insert、update、delete，以及在这之上的before, after    用途:       完整性检查，比如检查[0,100]      将表达式结果做为默认值，数据定义里的默认值只能是常量      ...  事件    事件是与一个时间表相关联的存储程序, 时间表用来定义事件发生的时间、次数以及何时消失。第5章 查询优化  5.1 使用索引    除了加快查询速度，也可以加快join的速度    索引使用太多了，优缺点都很清楚，也没有特别需要叙述的地方。      5.2 查询优化器    对数据表进行分析      分析索引值的分布情况，以便优化器做出更准确的评估。可以使用ANALYSE TABLE tbl_name，主动分析一次。          EXPLAIN      使用太频繁了，不用多介绍了      详见 附录1                指导优化器      可以force index, use index, ignore index，来指导优化器操作          尽量使用相同数据类型作比较      这个不是效率低下的主要原因，但严重的时候会导致优化器阻止使用索引，还是要注意一下，尽量不要让mysql作自动类型转换          索引列要简单、直观      where mycol * 2 < 4;  -- 不要这样写，mysql没有你聪明      where mycol < 4 / 2;  -- 正确写法          联结和子查询      优化器对联结的优化效果，远远高于对子查询的优化效果        5.3 数据类型的选择    不使用blob, text, varchar         这个不是绝对的，但任何一个可变长度，都将导致不能使用偏移定位下一行（某些情况可以把可变长度单独提出来建一张表)    尽量选择数值型，少选择字符串类型: 比如日期, ip地址, 字符串如果优先，也可以用ENUM代替    尽量选小类型，少选大类型:         这很困难，人都是懒惰的    尽量把列设置为NOT NULL:           NULL不仅不能节省空间，反而会增加空间开销，对性能也会有损失，因为每次需要多判断一次isnull    利用PROCEDURE ANALYSE:            让mysql提出自己的建议, SELECT * FROM tbl_name PROCEDURE ANALYSE();    定时清理表的碎片:                 blob, text, varchar, 都很容易造成碎片, 使用OPTIMIZE TABLE      5.4 有效加载数据    批量加载的效率比单行高      索引是放在键缓冲区的，每次索引的修改都会刷新键缓冲区到磁盘。批量只需要刷新一次就行了。      针对这点，有很多优化的方法        使用load data语句，避免insert        使用insert into tbl_name values(), (), ();        必须使用多条insert的时候，尽量用事务或锁括起来，也可以达到只刷新一次的目的。    加载时考虑索引的开销      MYISAM可以通过删除、失效索引等方式，加快加载速度。加载完成后，再重建索引      InnoDB不支持这种优化方式    使用较短的sql语句      较短的语句，意味着较小的网络传输，以及较短的sql解析时间      比如insert时，不用显式注明默认值        5.5 调度和锁定问题    MySQL默认的调度策略      写入比读取优先级更高      表的写操作一定的顺序的      表的读操作可以并行      可以人为改变调度策略      这些策略主要是针对MYISAM这样表锁的调度      改变语句的优先级        写操作(insert, delete, load_data, replace, update)          如果有个读操作A正在访问表，那么这是的写操作B就必须等待，又来了一个读操作C，由于写优先级比读高，所以C必须等待B (读并发降低了)          通过low_priority关键字，可以改变顺序为A, C, B (并发解决了，代价就是写操作可以一直无法执行)                  读操作(select)          通过high_priority关键字，可以插入到写操作之前，也可以插入到普通select之前                延迟插入        很像是low_priority，但low_priority会等待，客户端会被阻塞。使用delayed，可以将写数据存放到队列中，当空闲时一次性导入。        这样也是有代价的，就是宕机时，内存队列中的数据会丢失。              并发插入        MYISAM的特性，当数据没有空洞的时候，可以在尾部插入，而不影响读取            锁定级别与并发性      InnoDB采用行级锁，和那些表锁的调度方式完全不一样      InnoDB通过锁的级别来解决问题，好处是并发性得到了极大的提高。问题是出现了死锁的问题。(表锁是不会有死锁问题的)      死锁发生时，必须中止某个操作        5.6 系统管理员完成的优化      优化的主要原则        内存中访问比磁盘快        内存中尽可能长时间保存数据，减少磁盘活动        保留索引，比保留数据更重要              使用查询缓存        给定的select语句，服务器会记下它的查询文本和返回结果        有些select缓存没有意义，比如使用了now(), MySQL会自动不去缓存        可在select里，通过设置sql_cache, sql_no_cache，可是指定是否使用缓存        表被更新，缓存就会失效                  查询show variables like '%query_cache%'，可获取相关设置信息        包括缓存类型、大小、最大保存的查询结果大小等                硬件优化        更多的内存          内存多总是好的，太多的地方需要缓存        更快的磁盘          寻道时间通常是磁盘的瓶颈。就算更换更快的磁盘，也不能解决这个问题。相比而言，内存更加重要        分散读写磁盘          使用raid, 可以减少磁盘物理特性带来的影响                          PART 3 MySQL系统管理第10章 MySQL系统管理简介  10.1 MySQL组件    mysqld: 服务器端主程序。      mysqld_safe: 启动mysqld，在以外停机的时候，还可以重新启动mysqld。      mysqld_multi: 如果一台主机上启多个MySQL, 此脚本可以做到更好的管理。    mysql: 通过SQL语句和服务器交互的程序。也可执行SQL的批量脚本。    mysqladmin: 系统管理程序。可以关停服务器，检查配置，监控运行状态。    mysqldump: 导出表或数据库。导出的格式是SQL，可以用mysql来导入。此命令只能用于备份MyISAM。    mysqlhotcopy: 是文件级别的copy, 因此可用于MyISAM和InodDB，但只能在本地导出。    mysqlcheck: 表的修复工具，只能用在MyISAM      10.2 常规管理    服务器启动和关闭      手动和自动方式，异常时如何恢复重新工作。    用户账号的维护      哪个用户可以连接哪个服务器，从何处连接，可以干些什么    日志文件的维护      维护哪些日志，保存时间和方法    服务器的配置和优化      MySQL具备很高的可配置性。都希望服务器运行在最佳状态。不同的服务特点和硬件环境，都会影响MySQL的配置。    多个服务器的管理    MySQL软件更新        10.3 访问控制和安全性    文件系统的安全性    MySQL服务器的安全性      10.4 数据库的维护、备份、复制    预防性维护    数据库备份    崩溃恢复      通常需要备份 + 日志来恢复    数据库迁移    数据库复制      第11章 MySQL的数据目录  11.1 数据目录的位置    show variables like 'datadir'                                                                                                                                                                          附录1：EXPLAIN内容详解  id:                 本次select的标识符。在查询中每个select都有一个顺序的数值。  select_type:        select的类型，可能会有以下几种：                        simple: 简单的select(没有使用 union或子查询)                        primary: 最外层的select。                        union: 第二层，在select之后使用了union。                        dependent union: union语句中的第二个select，依赖于外部子查询                        subquery: 子查询中的第一个select                        dependent subquery: 子查询中的第一个subquery依赖于外部的子查询                        derived: 派生表select（from子句中的子查询）  table:              记录查询引用的表。  type:               表连接类型。以下列出了各种不同类型的表连接，依次是从最好的到最差的：                        system: 表只有一行记录(等于系统表)。这是const表连接类型的一个特例。                        const: 常数级别, 如 where primary_key = 1                        eq_ref: 从该表中会有一行记录被读取出来以和从前一个表中读取出来的记录做联合。与const类型不同的是，这是最好的连接类型。它用在索引所有部分都用于做连接并且这个索引是一个primary key 或 unique 类型。eq_ref可以用于在进行"="做比较时检索字段。比较的值可以是固定值或者是表达式，表达示中可以使用表里的字段，它们在读表之前已经准备好了。以下的几个例子中，mysql使用了eq_ref 连接来处理 ref_table：  possible_keys:      可能使用哪个索引。  key:                实际上用到的索引。  key_len：           key_len字段显示了mysql使用索引的长度。key_len的值可以告诉你在联合索引中mysql会真正使用了哪些索引。  ref：               哪些字段或者常量被用来和key配合从表中查询记录出来。  rows：              应该检索的记录数。  extra：             查询mysql的附加信息                        Distinct: 一旦MYSQL找到了与行相联合匹配的行，就不再搜索了                        Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了                        Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一                        Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行                        Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候                        Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上                        Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）                        system 表只有一行：system表。这是const连接类型的特殊情况                        const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待                        eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用                        ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少―越少越好                        range:这个连接类型使用索引返回一个范围中的行，比如使用>或                        index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）                        ALL: 完全扫描，应该尽量避免