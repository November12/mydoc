1. 主从复制和读写分离  对于普通的查询，mysql每秒查询次数只有3000次。  如果同时有大量数据的写入，由于锁的问题，会导致查询效率更低。  稍微规模大一点的应用，依靠单台mysql都无法满足需求。必须考虑集群处理方案。    而mysql并没有像hadoop那样的集群解决方案(毕竟是sql)，只能做简单的复制。  想做复制，有这样几种方法:  1) 分发    这是最简单的方式，其原理依然是一个个独立的mysql    通过数据分发程序(MQ)，发给每个mysql。    优点是非常简单，而且数据的一致性比较好，容易实现同步。    缺点也很明显，无法做到读写分离。  2) Mysql自带的主从复制    Mysql的复制原理依靠binlog。传送到slave后将命令重新执行一遍。(基于语句的复制, slave只能有一个master)    这种复制方法显然不是万能的，有时候会无法实现。如 where 时间戳 < $time    因此，mysql5.0之后，加上了基于记录(行)的复制作为辅助。    值得一提的是，这种复制可以级联，一层层的复制下去。(但延迟现象会越来越明显)    由于基于语句，因此binlog压缩后数据量非常小。但slave的写入压力并没有减轻。(由于批量操作，会有一些优化，但效果不明显; 另外，可以只写入指定表，这样可以减轻负担)  3) MySQL-Transefer    通过MySQL + patch得到的一种解决方案。    和原生的主从复制相比较，可以接收多个master。可以认为多个binlog。    这有什么好处呢? 一个是可以利用多线程处理，另一个就是master这一层，可以实现分库。        总体来说，mysql的主从，并没有给我们带来更多的解决方案。  但有一点是能形成共识的，那就是通过多slave，读写分离来提供sql服务。  2. 负载均衡和故障切换  我们已经有了多个供查询的slave。但该去哪个slave查询呢? 这点还是最好不要暴露给应用开发。  对于应用开发，最好是让他们认为只有一个mysql，一个永远不会宕机的，永远高性能的mysql。    2.1 mysql proxy        3. 存储引擎的选择  myisam  innodb      