1. 介绍  ########################################################
bigtable的设计目的
  1. PB级别的数据储存
  2. 高性能、可用性
  2. 适用性、伸缩性
  
google的很多项目都使用bigtable来存储。包括网页，earth, 金融等60多个应用。这些业务特点很不一样，充分的显示出bigtable的适用性。
数据下标是行和列，数据本身是任何字符串，意义由用户自己解释。
客户可以决定数据存放在内存还是硬盘上。



2. 数据模型 #####################################################
bigtable是一个稀疏的，持久的，多维度的，排序的映射表。
表的索引是行关键字，列关键字和时间戳。
(row:string, column:string, time:int64) -> string

"com.cnn.www"                     // row
{
  "contents"                      // column
  {
    t6: "<html>..."               // timestamp:value
    t5: "<html>..."
    t3: "<html>..."
  }
  
  "anchor:cnnsi.com"              // column family:column
  {
    t9: "CNN"
  }
  
  "anchor:my.look.ca"             
  {
    t8:"CNN.com"
  }
}


2.1 行(Rows)
行关键字(row keys)可以是任意的字符串。(<64KB，用不了这么多)
任何一个对行的读写操作，都是原子的。
bigtable存储数据就是通过row keys来排序的。

2.2 片(tablet)
Bigtable的表会根据row keys自动划分为片。
片是负载均衡的单元。最初表都只有一个片，但随着表不断增大，片会自动分裂，片的大小控制在100-200MB。
所以，相似的row keys会放在一起，这个特性在选择row keys的时候至关重要。

2.3 列(Column)
列是第二级索引，每行拥有的列是不受限制的，可以随时增加减少。
列族名必须是可打印字符，但列关键字可以是任意字符串。

2.4 列族(Column Families)
为了方便管理，列被分为多个列族。
列族是访问控制的基本单位。列族下的数据一起压缩存放，因此必须保证是同一类型。列族必须先创建，才能使用。
一张表里面的列族不能太多，而且尽量不要改变列族。
访问控制，磁盘使用统计，内存使用统计都可以在列族这个层面进行。

2.5 时间戳
时间戳是第三级索引。
bigtable表中每一个表项都可以包含多个版本，通过时间戳来索引。
时间戳是64位整型，可以准确到毫秒。可以有bigtable自动赋值，也可以由应用程序来赋值。
bigtable的垃圾清除机制,可以有两种方式: 1. 只保留最后的N个版本 2. 只保留最近N天的版本




3. API ########################################################
bigtable不支持跨行的关键字处理。
bigtable允许客户端提交脚本到服务器。
bigtable可以和MapReduce一起使用，作为数据的源头和输出结果。




4. BigTable构件  #############################################
分布式文件系统(GFS):
  存储日志文件和数据文件
集群管理系统:
  管理一个机器池。池中的机器运行bigtable，也会运行其它程序。
  集群管理系统负责调度任务、共享资源、监控状态。
SSTable:
  一个持久化的、排序的、不可更改的Map结构。
  通常一个SSTables是64KB。
  在SSTable的最后，会有一个块索引。块索引是一个双向链接，通过二分法进行查找。
  打开SSTable的时候，索引就被加载至内存。因此，只需要访问一次磁盘，即可找到数据。
  当然，也可以通过配置，把整个SSTable都加载至内存。
Chubby:
  一个高可用的、序列化的分布式锁服务组件。
  一个Chubby服务包括了5个活动的副本，其中的一个副本被选为Master，通过Paxos算法来保证副本的一致性。
  


5. 实现 ########################################################
bigtable有3个主要组件:
1. 一个Master服务器
  为Tablet服务器分配Tablets
  监测加入或失效的Tablet服务器
  Tablet服务器的负载均衡
  修改表或列族等对表结构的修改
  GFS上的文件进行垃圾收集

2. 多个Tablet服务器
  每个Tablet服务器都管理一个Tablet的集合(可能有上千个Tablet)
  每个Tablet的默认大小是100-200MB
  Tablet服务器负责对Tablet的读写，分割。
  客户端不需要通过Master来获取Tablet的位置信息，所以Master负荷其实很轻。(定位是在chubby做的)
 
  Tablet的位置:
    类似Ｂ+树的结构存储Tablet的位置信息
    chubby file -> root tablet -> meta tablet -> user tablet
    meta tablet: 
      key: 
      value: 位置信息
      

  
子表的地址:
子表地址信息储存在一个三层类似B+树的结构中
第一层是Chubby中的一个文件，














