http://www.slideshare.net/mongodb/mongodb-indexing-the-details        1. Basic Index Bounds以下例子都是在 {x:1} 索引下的结果1.1 Equality Match  db.c.find({x:3})  "indexBounds" : {     "x" : [         [             3,    <- 这其实也是一个区间             3         ]     ]  }   1.2 Full Document Matcher  db.find({x:6, y:1})  因为y不在索引里面，所以需要查询每个document  1.3 Range Match && Exclusive Range Match  db.c.find({x:{$gte:4, $lte:7}})  db.c.find({x:{$gt:4, $lt:7}})    -> Exclusive Range Match  会寻找>4的第一个节点，<7的第一个节点(少遍历两个节点)   1.4 Range Type  1. Explicit inequality    db.c.find({x:{$gt:4, $lt:7}})    db.c.find({x:{$gt:4}})    db.c.find({x:{$ne:4}})  2. Regular expression prefix    db.c.find({x:/^a/})  3. Data type    db.c.find({x:/a/})1.5 Set(集合) Match  db.c.find({x:{$in:[3,6]}})  "nscanned" : 3,  "nscannedObjects" : 2,   <- 只有不相交的区间查询，才会出现这种情况(nscannedObjects < nscanned)  "n" : 2,  1.6 All Match  db.c.find({x:{$all:[3,6]}})  "indexBounds" : {    "x" : [      [        3,  <- 会以最左边的一个元素作为索引，所以确保这个元素的数据是最少的        3      ]    ]  }        1.7 sort  db.c.find({x:{$gt: 3}}).sort({y:1})  "scanAndOrder" : true,       <- 只有为true的时候，这行才会显示; 如果是sort({x:1}), 就不会出现这行  为true代表区间内的所有节点都需要被遍历，最后在内存中进行排序。  1.8 count  1.9 full document  db.c.find({x:{$gt: 3}}, {x:1, _id:0}).explain()  "indexOnly" : true     -> 默认会打印_id，意味着full document    2. Compound Key Index Bounds  以下例子都是在 {x:1, y:1} 索引下的结果  > db.d.find({}, {x:1, y:1, _id:0})  { "x" : 1, "y" : "b" }  { "x" : 3, "y" : "d" }  { "x" : 4, "y" : "g" }  { "x" : 5, "y" : "c" }  { "x" : 5, "y" : "d" }  { "x" : 5, "y" : "f" }  { "x" : 6, "y" : "c" }  { "x" : 7, "y" : "a" }  { "x" : 9, "y" : "b" }  2.1 Two Equality Bounds  db.d.find({x:5, y:'c'})  同 Basic Index Bounds 处理  2.2 Equality and Set  db.d.find({x:5, y:{$in:['c','f']}})  "nscanned" : 3,         -> 扫描[5/c, 5/f]区间,共3个节点  "nscannedObjects" : 2,  -> 5/d显然不满足要求，不需要扫描5/d这个document  2.3 Equality and Range  db.d.find({x:5, y:{$gte:'d'}})  [5/d, 5/max]区间  2.4 Two Set Bounds  db.d.find({x:{$in:[5,9]}, y:{$in:['c','f']}})  [5/c, 5/f]区间 和 [9/c, 9/f]区间, 顺序显得尤为重要  2.5 Set and Range ("nscanned" : 5,????)  db.d.find({x:{$in:[5,9]}, y:{$lte:'d'}})  [5/min, 5/d]区间 和 [9/min, 9/d]区间  2.6 Range and Equality  db.d.find({x:{$gte:4}, y:'c'})  [4/c, max/c]区间  2.7 Range and Set  db.d.find({x:{$gte:4}, y:{$in:['c', 'a']}})  ????("nscanned" : 6, 而不是7)  2.8 Two Ranges(2D Box)  db.d.find({x:{$gte:3,$lte:7}, y:{$gte:'c', $lte:'f'}})  [3/c, 7/f]区间  2.9 Disjoint $or Criteria  db.d.find({$or:[{x:5},{y:'d'}]})  case 1:  index {x:1, y:1}   [5/min, 5/max]区间 和 遍历所有节点(BasicCursor)  总共遍历了12个节点，比没有索引的时候，效率更低  case 2:  index {x:1} {y:1}  [5, 5]区间 和 ['d', 'd']区间  case 3:  index {x:1}  遍历所有节点(BasicCursor), 9个节点  2.10 Eliminated $or Clause  db.d.find({$or:[{x:{$gt:2,$lt:6}}, {x:5}]})  因为第二个区间在第一个之内，所以优化成了一个区间  db.d.find({$or:[{x:{$gt:2,$lt:6},y:'c'}, {x:5,y:'d'}]})  会分成两个区间  3. Optimal Index 好的索引  没有scanAndOrder  没有full document(所有条件都可以通过索引筛选)  查询索引的顺序，遵循 equlity -> sort -> range  如果同是range，小范围的总应该放在前面        $or是需要非常慎重选择的关键字                            db.c.find({})        db.c.find({})           