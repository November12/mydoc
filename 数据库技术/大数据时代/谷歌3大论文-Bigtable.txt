一. Bigtable：一个分布式的结构化数据存储系统   *************************************************************************
  1. 介绍
    设计目的: 可靠的处理PB级别的数据，并且能够部署到上千台机器上。
    设计特点: 
      1. 适用性广泛
        有的需要高吞吐量的批处理，有的则需要及时响应，快速返回数据给最终用户
      2. 可扩展
        ，有的集群只有几台服务器，而有的则需要上千台服务器
      3. 高性能和高可用
      
    Bigtable和关系型数据库相比:
      1. 可以动态控制数据的分布和格式. (非关系型数据库基本都有此特点)
      2. 可以推测存储位置的相关性. (这个对于优化来说，非常有用，根据数据的相关性，一次性将数据读取出来)
      3. 可以控制数据是存储在内存，还是硬盘.
      
  2. 数据模型
    Bigtable是一个稀疏的、分布式的、持久化存储的多维度排序Map.
      (row:string, column:string,time:int64) -> string
    
    1. 行关键字 - 对数据的物理控制
      对同一行的读写操作都是原子的. (这是必须的，否是数据将不可用)
      
      Bigtable通过行关键字的字典顺序来组织数据。若干连续的行在一起，组成了一个Tablet。（Tablet是数据分布和负载均衡调整的最小单位.)
      可见，行是与物理存储相关的，通过组织行关键字，可以利用相关性提高效率。(例如: 反向url)
      
    2. 列族 - 对数据的逻辑控制
      列关键字组成的集合叫做“列族“，列族是访问控制的基本单位。而且磁盘和内存的使用统计都是在列族层面进行的
      存放在同一列族下的所有数据通常都属于同一个类型.(同一个列族下的数据一起压缩)
      列族使用前必须先创建.(告诉系统如何压缩)
      根据我们的设计意图，一张表中的列族不能太多（最多几百个），并且列族在运行期间很少改变。与之相对应的，一张表可以有无限多个列。
      
    3. 时间戳 - 对数据的版本控制
      Bigtable时间戳的类型是64位整型。Bigtable可以给时间戳赋值，用来表示精确到毫秒的“实时”时间；用户程序也可以给时间戳赋值。
      时间戳是版本控制的重要依据，可以灵活选择历史版本的处理方式. 
        方式1: 只保留最近n天的数据
        方式2: 只保留最新的n个版本
      
  3. API
    bigtable不支持跨行的关键字处理。
    bigtable允许客户端提交脚本到服务器。
    bigtable可以和MapReduce一起使用，作为数据的源头和输出结果。
    
  4. BigTable构件
    Bigtable是建立在其它的几个Google基础构件上的。
    1. 分布式文件系统(GFS):
      存储日志文件和数据文件
    2. 集群管理系统:
      管理一个机器池。池中的机器运行bigtable，也会运行其它程序。
      集群管理系统负责调度任务、共享资源、监控状态。
    3. SSTable:
      一个持久化的、排序的、不可更改的Map结构。
      通常一个SSTables是64KB。
      在SSTable的最后，会有一个块索引。块索引是一个双向链接，通过二分法进行查找。
      打开SSTable的时候，索引就被加载至内存。因此，只需要访问一次磁盘，即可找到数据。
      当然，也可以通过配置，把整个SSTable都加载至内存。
    4. Chubby:
      一个高可用的、序列化的分布式锁服务组件。
      一个Chubby服务包括了5个活动的副本，其中的一个副本被选为Master，通过Paxos算法来保证副本的一致性。
    
  5. 实现
    bigtable有3个主要组件:
    1. 一个Master服务器
      为Tablet服务器分配Tablets
      监测加入或失效的Tablet服务器
      Tablet服务器的负载均衡
      修改表或列族等对表结构的修改
      GFS上的文件进行垃圾收集

    2. 多个Tablet服务器
      每个Tablet服务器都管理一个Tablet的集合(可能有上千个Tablet)
      每个Tablet的默认大小是100-200MB
      Tablet服务器负责对Tablet的读写，分割。
      客户端不需要通过Master来获取Tablet的位置信息，所以Master负荷其实很轻。(定位是在chubby做的)
     
      Tablet的位置:
        类似Ｂ+树的结构存储Tablet的位置信息
        chubby file -> root tablet -> meta tablet -> user tablet
        meta tablet: 
          key: 
          value: 位置信息
    
    3. 链接到客户程序中的库
      
      
      
      